/* This code was generated by Usuba.
   See https://github.com/DadaIsCrazy/usuba.
   From the file "nist/photon/usuba/ua/photon_vslice.ua" (included below). */

#include <stdint.h>

/* Do NOT change the order of those define/include */

#ifndef BITS_PER_REG
#define BITS_PER_REG 4
#endif
/* including the architecture specific .h */
#include "STD.h"

/* auxiliary functions */
void Sbox__V4 (/*inputs*/ DATATYPE x__, /*outputs*/ DATATYPE* y__) {
   static const DATATYPE t[16] = { 12,5,6,11,9,0,10,13,3,14,15,8,4,7,1,2 };
   *y__ = t[x__];
}

void SubCells__V4 (/*inputs*/ DATATYPE x__[8][8], /*outputs*/ DATATYPE y__[8][8]) {

  // Variables declaration
  ;

  // Instructions (body)
  for (int i__ = 0; i__ <= 7; i__++) {
    for (int j__ = 0; j__ <= 7; j__++) {
      Sbox__V4(x__[i__][j__],&y__[i__][j__]);
    }
  }

}

void ShiftRows__V4 (/*inputs*/ DATATYPE x__[8][8], /*outputs*/ DATATYPE y__[8][8]) {

  // Variables declaration
  ;

  // Instructions (body)
  for (int i__ = 0; i__ <= 7; i__++) {
    for (int j__ = 0; j__ <= 7; j__++) {
      y__[i__][j__] = x__[i__][((j__ + i__) % 8)];
    }
  }

}

void AddConstant__V4 (/*inputs*/ DATATYPE x__[8][8],DATATYPE rc__, /*outputs*/ DATATYPE y__[8][8]) {

  // Variables declaration
  DATATYPE IC__[8];
  DATATYPE _tmp9_;

  // Instructions (body)
  IC__[0] = LIFT_4(0);
  IC__[1] = LIFT_4(1);
  IC__[2] = LIFT_4(3);
  IC__[3] = LIFT_4(7);
  IC__[4] = LIFT_4(15);
  IC__[5] = LIFT_4(14);
  IC__[6] = LIFT_4(12);
  IC__[7] = LIFT_4(8);
  for (int i__ = 0; i__ <= 7; i__++) {
    _tmp9_ = XOR(x__[i__][0],rc__);
    y__[i__][0] = XOR(_tmp9_,IC__[i__]);
    y__[i__][1] = x__[i__][1];
    y__[i__][2] = x__[i__][2];
    y__[i__][3] = x__[i__][3];
    y__[i__][4] = x__[i__][4];
    y__[i__][5] = x__[i__][5];
    y__[i__][6] = x__[i__][6];
    y__[i__][7] = x__[i__][7];
  }

}

void xtimes__V4 (/*inputs*/ DATATYPE e__, /*outputs*/ DATATYPE* e____) {

  // Variables declaration
  DATATYPE _tmp12_;
  DATATYPE _tmp13_;
  DATATYPE c__;
  DATATYPE t__;

  // Instructions (body)
  t__ = L_SHIFT(e__,1,4);
  c__ = R_SHIFT(e__,3,4);
  _tmp12_ = XOR(t__,c__);
  _tmp13_ = L_SHIFT(c__,1,4);
  *e____ = XOR(_tmp12_,_tmp13_);

}

void step__V4 (/*inputs*/ DATATYPE x__[8], /*outputs*/ DATATYPE x____[8]) {

  // Variables declaration
  DATATYPE _shadow_acc__1_;
  DATATYPE _shadow_acc__2_;
  DATATYPE _shadow_acc__3_;
  DATATYPE _shadow_acc__4_;
  DATATYPE _shadow_acc__5_;
  DATATYPE _shadow_acc__6_;
  DATATYPE _shadow_acc__7_;
  DATATYPE _tmp15_;
  DATATYPE _tmp16_;
  DATATYPE _tmp17_;
  DATATYPE _tmp18_;
  DATATYPE _tmp19_;
  DATATYPE _tmp20_;
  DATATYPE _tmp21_;

  // Instructions (body)
  _shadow_acc__1_ = XOR(x__[3],x__[5]);
  xtimes__V4(_shadow_acc__1_,&_shadow_acc__2_);
  _tmp15_ = XOR(_shadow_acc__2_,x__[1]);
  _tmp16_ = XOR(_tmp15_,x__[6]);
  _shadow_acc__3_ = XOR(_tmp16_,x__[7]);
  xtimes__V4(_shadow_acc__3_,&_shadow_acc__4_);
  _tmp17_ = XOR(_shadow_acc__4_,x__[0]);
  _tmp18_ = XOR(_tmp17_,x__[2]);
  _tmp19_ = XOR(_tmp18_,x__[3]);
  _tmp20_ = XOR(_tmp19_,x__[4]);
  _shadow_acc__5_ = XOR(_tmp20_,x__[7]);
  xtimes__V4(_shadow_acc__5_,&_shadow_acc__6_);
  _tmp21_ = XOR(_shadow_acc__6_,x__[3]);
  _shadow_acc__7_ = XOR(_tmp21_,x__[6]);
  x____[0] = x__[1];
  x____[1] = x__[2];
  x____[2] = x__[3];
  x____[3] = x__[4];
  x____[4] = x__[5];
  x____[5] = x__[6];
  x____[6] = x__[7];
  x____[7] = _shadow_acc__7_;

}

void MixColumnRow__V4 (/*inputs*/ DATATYPE X__0__,DATATYPE X__1__,DATATYPE X__2__,DATATYPE X__3__,DATATYPE X__4__,DATATYPE X__5__,DATATYPE X__6__,DATATYPE X__7__, /*outputs*/ DATATYPE* Y__0__,DATATYPE* Y__1__,DATATYPE* Y__2__,DATATYPE* Y__3__,DATATYPE* Y__4__,DATATYPE* Y__5__,DATATYPE* Y__6__,DATATYPE* Y__7__) {

  // Variables declaration
  DATATYPE x__[8];

  // Instructions (body)
  x__[0] = X__0__;
  x__[1] = X__1__;
  x__[2] = X__2__;
  x__[3] = X__3__;
  x__[4] = X__4__;
  x__[5] = X__5__;
  x__[6] = X__6__;
  x__[7] = X__7__;
  for (int i__ = 0; i__ <= 7; i__++) {
    step__V4(x__,x__);
  }
  *Y__0__ = x__[0];
  *Y__1__ = x__[1];
  *Y__2__ = x__[2];
  *Y__3__ = x__[3];
  *Y__4__ = x__[4];
  *Y__5__ = x__[5];
  *Y__6__ = x__[6];
  *Y__7__ = x__[7];

}

void MixColumnSerial__V4 (/*inputs*/ DATATYPE X__[8][8], /*outputs*/ DATATYPE Y__[8][8]) {

  // Variables declaration
  ;

  // Instructions (body)
  for (int i__ = 0; i__ <= 7; i__++) {
    MixColumnRow__V4(X__[0][i__],X__[1][i__],X__[2][i__],X__[3][i__],X__[4][i__],X__[5][i__],X__[6][i__],X__[7][i__],&Y__[0][i__],&Y__[1][i__],&Y__[2][i__],&Y__[3][i__],&Y__[4][i__],&Y__[5][i__],&Y__[6][i__],&Y__[7][i__]);
  }

}

/* main function */
void Photon__ (/*inputs*/ DATATYPE plain__[8][8], /*outputs*/ DATATYPE cipher__[8][8]) {

  // Variables declaration
  DATATYPE RC__[12];
  DATATYPE _tmp35_[8][8];
  DATATYPE _tmp36_[8][8];
  DATATYPE _tmp37_[8][8];
  DATATYPE state__[8][8];

  // Instructions (body)
  RC__[0] = LIFT_4(1);
  RC__[1] = LIFT_4(3);
  RC__[2] = LIFT_4(7);
  RC__[3] = LIFT_4(14);
  RC__[4] = LIFT_4(13);
  RC__[5] = LIFT_4(11);
  RC__[6] = LIFT_4(6);
  RC__[7] = LIFT_4(12);
  RC__[8] = LIFT_4(9);
  RC__[9] = LIFT_4(2);
  RC__[10] = LIFT_4(5);
  RC__[11] = LIFT_4(10);
  state__[0][0] = plain__[0][0];
  state__[0][1] = plain__[0][1];
  state__[0][2] = plain__[0][2];
  state__[0][3] = plain__[0][3];
  state__[0][4] = plain__[0][4];
  state__[0][5] = plain__[0][5];
  state__[0][6] = plain__[0][6];
  state__[0][7] = plain__[0][7];
  state__[1][0] = plain__[1][0];
  state__[1][1] = plain__[1][1];
  state__[1][2] = plain__[1][2];
  state__[1][3] = plain__[1][3];
  state__[1][4] = plain__[1][4];
  state__[1][5] = plain__[1][5];
  state__[1][6] = plain__[1][6];
  state__[1][7] = plain__[1][7];
  state__[2][0] = plain__[2][0];
  state__[2][1] = plain__[2][1];
  state__[2][2] = plain__[2][2];
  state__[2][3] = plain__[2][3];
  state__[2][4] = plain__[2][4];
  state__[2][5] = plain__[2][5];
  state__[2][6] = plain__[2][6];
  state__[2][7] = plain__[2][7];
  state__[3][0] = plain__[3][0];
  state__[3][1] = plain__[3][1];
  state__[3][2] = plain__[3][2];
  state__[3][3] = plain__[3][3];
  state__[3][4] = plain__[3][4];
  state__[3][5] = plain__[3][5];
  state__[3][6] = plain__[3][6];
  state__[3][7] = plain__[3][7];
  state__[4][0] = plain__[4][0];
  state__[4][1] = plain__[4][1];
  state__[4][2] = plain__[4][2];
  state__[4][3] = plain__[4][3];
  state__[4][4] = plain__[4][4];
  state__[4][5] = plain__[4][5];
  state__[4][6] = plain__[4][6];
  state__[4][7] = plain__[4][7];
  state__[5][0] = plain__[5][0];
  state__[5][1] = plain__[5][1];
  state__[5][2] = plain__[5][2];
  state__[5][3] = plain__[5][3];
  state__[5][4] = plain__[5][4];
  state__[5][5] = plain__[5][5];
  state__[5][6] = plain__[5][6];
  state__[5][7] = plain__[5][7];
  state__[6][0] = plain__[6][0];
  state__[6][1] = plain__[6][1];
  state__[6][2] = plain__[6][2];
  state__[6][3] = plain__[6][3];
  state__[6][4] = plain__[6][4];
  state__[6][5] = plain__[6][5];
  state__[6][6] = plain__[6][6];
  state__[6][7] = plain__[6][7];
  state__[7][0] = plain__[7][0];
  state__[7][1] = plain__[7][1];
  state__[7][2] = plain__[7][2];
  state__[7][3] = plain__[7][3];
  state__[7][4] = plain__[7][4];
  state__[7][5] = plain__[7][5];
  state__[7][6] = plain__[7][6];
  state__[7][7] = plain__[7][7];
  for (int i__ = 0; i__ <= 11; i__++) {
    AddConstant__V4(state__,RC__[i__],_tmp35_);
    SubCells__V4(_tmp35_,_tmp36_);
    ShiftRows__V4(_tmp36_,_tmp37_);
    MixColumnSerial__V4(_tmp37_,state__);
  }
  cipher__[0][0] = state__[0][0];
  cipher__[0][1] = state__[0][1];
  cipher__[0][2] = state__[0][2];
  cipher__[0][3] = state__[0][3];
  cipher__[0][4] = state__[0][4];
  cipher__[0][5] = state__[0][5];
  cipher__[0][6] = state__[0][6];
  cipher__[0][7] = state__[0][7];
  cipher__[1][0] = state__[1][0];
  cipher__[1][1] = state__[1][1];
  cipher__[1][2] = state__[1][2];
  cipher__[1][3] = state__[1][3];
  cipher__[1][4] = state__[1][4];
  cipher__[1][5] = state__[1][5];
  cipher__[1][6] = state__[1][6];
  cipher__[1][7] = state__[1][7];
  cipher__[2][0] = state__[2][0];
  cipher__[2][1] = state__[2][1];
  cipher__[2][2] = state__[2][2];
  cipher__[2][3] = state__[2][3];
  cipher__[2][4] = state__[2][4];
  cipher__[2][5] = state__[2][5];
  cipher__[2][6] = state__[2][6];
  cipher__[2][7] = state__[2][7];
  cipher__[3][0] = state__[3][0];
  cipher__[3][1] = state__[3][1];
  cipher__[3][2] = state__[3][2];
  cipher__[3][3] = state__[3][3];
  cipher__[3][4] = state__[3][4];
  cipher__[3][5] = state__[3][5];
  cipher__[3][6] = state__[3][6];
  cipher__[3][7] = state__[3][7];
  cipher__[4][0] = state__[4][0];
  cipher__[4][1] = state__[4][1];
  cipher__[4][2] = state__[4][2];
  cipher__[4][3] = state__[4][3];
  cipher__[4][4] = state__[4][4];
  cipher__[4][5] = state__[4][5];
  cipher__[4][6] = state__[4][6];
  cipher__[4][7] = state__[4][7];
  cipher__[5][0] = state__[5][0];
  cipher__[5][1] = state__[5][1];
  cipher__[5][2] = state__[5][2];
  cipher__[5][3] = state__[5][3];
  cipher__[5][4] = state__[5][4];
  cipher__[5][5] = state__[5][5];
  cipher__[5][6] = state__[5][6];
  cipher__[5][7] = state__[5][7];
  cipher__[6][0] = state__[6][0];
  cipher__[6][1] = state__[6][1];
  cipher__[6][2] = state__[6][2];
  cipher__[6][3] = state__[6][3];
  cipher__[6][4] = state__[6][4];
  cipher__[6][5] = state__[6][5];
  cipher__[6][6] = state__[6][6];
  cipher__[6][7] = state__[6][7];
  cipher__[7][0] = state__[7][0];
  cipher__[7][1] = state__[7][1];
  cipher__[7][2] = state__[7][2];
  cipher__[7][3] = state__[7][3];
  cipher__[7][4] = state__[7][4];
  cipher__[7][5] = state__[7][5];
  cipher__[7][6] = state__[7][6];
  cipher__[7][7] = state__[7][7];

}

/* Additional functions */
uint32_t bench_speed() {
  /* inputs */
  DATATYPE plain__[8][8] = { 0 };
  /* outputs */
  DATATYPE cipher__[8][8] = { 0 };
  /* fun call */
  Photon__(plain__,cipher__);

  /* Returning the number of encrypted bytes */
  return 32;
}

/* **************************************************************** */
/*                            Usuba source                          */
/*                                                                  */
/*

 _no_inline table Sbox(x :  u4 :: base)
  returns y :  u4 :: base
{
  12, 5, 6, 11, 9, 0, 10, 13, 3, 14, 15, 8, 4, 7, 1, 2
}


 node SubCells(x :  u4[8][8] :: base)
  returns y :  u4[8][8] :: base
vars

let
  forall i in [0,7] {
    forall j in [0,7] {
      (y[i][j]) = Sbox(x[i][j])
    }
  }
tel

 node ShiftRows(x :  u4[8][8] :: base)
  returns y :  u4[8][8] :: base
vars

let
  forall i in [0,7] {
    forall j in [0,7] {
      (y[i][j]) = x[i][((j + i) % 8)]
    }
  }
tel

 node AddConstant(x :  u4[8][8] :: base,rc :  u4 :: base)
  returns y :  u4[8][8] :: base
vars
  IC :  u4[8] :: base
let
  (IC) = (0,1,3,7,15,14,12,8);
  forall i in [0,7] {
    (y[i][0]) = ((x[i][0] ^ rc) ^ IC[i]);
    (y[i][1 .. 7]) = x[i][1 .. 7]
  }
tel

 node xtimes(e :  u4 :: base)
  returns e' :  u4 :: base
vars
  t :  u4 :: base,
  c :  u4 :: base
let
  (t) = (e << 1);
  (c) = (e >> 3);
  (e') = (((t & 15) ^ c) ^ (c << 1))
tel

 node step(x :  u4[8] :: base)
  returns x' :  u4[8] :: base
vars
  acc :  u4 :: base
let
  (acc) = 0;
  (acc) := ((acc ^ x[3]) ^ x[5]);
  (acc) := xtimes(acc);
  (acc) := (((acc ^ x[1]) ^ x[6]) ^ x[7]);
  (acc) := xtimes(acc);
  (acc) := (((((acc ^ x[0]) ^ x[2]) ^ x[3]) ^ x[4]) ^ x[7]);
  (acc) := xtimes(acc);
  (acc) := ((acc ^ x[3]) ^ x[6]);
  (x') = (x[1 .. 7],acc)
tel

 node MixColumnRow(X :  u4[8] :: base)
  returns Y :  u4[8] :: base
vars
  x :  u4[9][8] :: base,
  y :  u4[9] :: base
let
  forall i in [0,7] {
    (x[0][i]) = (X[i] & 15)
  };
  forall i in [0,7] {
    (x[(i + 1)]) = step(x[i])
  };
  (Y) = x[8]
tel

 node MixColumnSerial(X :  u4[8][8] :: base)
  returns Y :  u4[8][8] :: base
vars

let
  forall i in [0,7] {
    (Y[0 .. 7][i]) = MixColumnRow(X[0 .. 7][i])
  }
tel

 node Photon(plain :  u4[8][8] :: base)
  returns cipher :  u4[8][8] :: base
vars
  RC :  u4[12] :: base,
  state :  u4[13][8][8] :: base
let
  (RC) = (1,3,7,14,13,11,6,12,9,2,5,10);
  (state[0]) = plain;
  forall i in [0,11] {
    (state[(i + 1)]) = MixColumnSerial(ShiftRows(SubCells(AddConstant(state[i],RC[i]))))
  };
  (cipher) = state[12]
tel

*/
 