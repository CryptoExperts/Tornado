/* This code was generated by Usuba.
   See https://github.com/DadaIsCrazy/usuba.
   From the file "nist/ascon/usuba/ua/ascon.ua" (included below). */

#include <stdint.h>

/* Do NOT change the order of those define/include */

#ifndef BITS_PER_REG
#define BITS_PER_REG 64
#endif
/* including the architecture specific .h */
#include "MASKED_UA.h"

/* auxiliary functions */
void Sbox__V64 (/*inputs*/ DATATYPE x[5][MASKING_ORDER], /*outputs*/ DATATYPE xr[5][MASKING_ORDER]) {

  // Variables declaration
  DATATYPE _shadow_t04_[MASKING_ORDER];
  DATATYPE _shadow_t15_[MASKING_ORDER];
  DATATYPE _shadow_t26_[MASKING_ORDER];
  DATATYPE _shadow_t37_[MASKING_ORDER];
  DATATYPE _shadow_t48_[MASKING_ORDER];
  DATATYPE _shadow_x015_;
  DATATYPE _shadow_x01_[MASKING_ORDER];
  DATATYPE _shadow_x09_;
  DATATYPE _shadow_x110_;
  DATATYPE _shadow_x114_;
  DATATYPE _shadow_x211_[MASKING_ORDER];
  DATATYPE _shadow_x217_[MASKING_ORDER];
  DATATYPE _shadow_x23_[MASKING_ORDER];
  DATATYPE _shadow_x312_;
  DATATYPE _shadow_x316_;
  DATATYPE _shadow_x413_;
  DATATYPE _shadow_x42_[MASKING_ORDER];
  DATATYPE t0[MASKING_ORDER];
  DATATYPE t1[MASKING_ORDER];
  DATATYPE t2[MASKING_ORDER];
  DATATYPE t3[MASKING_ORDER];
  DATATYPE t4[MASKING_ORDER];

  // Instructions (body)
  for (int _mask_idx = 0; _mask_idx <= (MASKING_ORDER - 1); _mask_idx++) {
    _shadow_x01_[_mask_idx] = XOR(x[0][_mask_idx],x[4][_mask_idx]);
    _shadow_x42_[_mask_idx] = XOR(x[4][_mask_idx],x[3][_mask_idx]);
    _shadow_x23_[_mask_idx] = XOR(x[2][_mask_idx],x[1][_mask_idx]);
  }
  t0[0] = NOT(_shadow_x01_[0]);
  for (int _mask_idx = 1; _mask_idx <= (MASKING_ORDER - 1); _mask_idx++) {
    t0[_mask_idx] = _shadow_x01_[_mask_idx];
    t1[_mask_idx] = x[1][_mask_idx];
    t2[_mask_idx] = _shadow_x23_[_mask_idx];
    t3[_mask_idx] = x[3][_mask_idx];
    t4[_mask_idx] = _shadow_x42_[_mask_idx];
  }
  t1[0] = NOT(x[1][0]);
  t2[0] = NOT(_shadow_x23_[0]);
  t3[0] = NOT(x[3][0]);
  t4[0] = NOT(_shadow_x42_[0]);
  MASKED_AND(_shadow_t04_,t0,x[1]);
  MASKED_AND(_shadow_t15_,t1,_shadow_x23_);
  MASKED_AND(_shadow_t26_,t2,x[3]);
  MASKED_AND(_shadow_t37_,t3,_shadow_x42_);
  MASKED_AND(_shadow_t48_,t4,_shadow_x01_);
  for (int _mask_idx = 0; _mask_idx <= (MASKING_ORDER - 1); _mask_idx++) {
    _shadow_x09_ = XOR(_shadow_x01_[_mask_idx],_shadow_t15_[_mask_idx]);
    _shadow_x110_ = XOR(x[1][_mask_idx],_shadow_t26_[_mask_idx]);
    _shadow_x211_[_mask_idx] = XOR(_shadow_x23_[_mask_idx],_shadow_t37_[_mask_idx]);
    _shadow_x312_ = XOR(x[3][_mask_idx],_shadow_t48_[_mask_idx]);
    _shadow_x413_ = XOR(_shadow_x42_[_mask_idx],_shadow_t04_[_mask_idx]);
    _shadow_x114_ = XOR(_shadow_x110_,_shadow_x09_);
    _shadow_x015_ = XOR(_shadow_x09_,_shadow_x413_);
    _shadow_x316_ = XOR(_shadow_x312_,_shadow_x211_[_mask_idx]);
    xr[0][_mask_idx] = _shadow_x015_;
    xr[1][_mask_idx] = _shadow_x114_;
    xr[3][_mask_idx] = _shadow_x316_;
    xr[4][_mask_idx] = _shadow_x413_;
  }
  _shadow_x217_[0] = NOT(_shadow_x211_[0]);
  for (int _mask_idx = 1; _mask_idx <= (MASKING_ORDER - 1); _mask_idx++) {
    _shadow_x217_[_mask_idx] = _shadow_x211_[_mask_idx];
  }
  for (int _mask_idx = 0; _mask_idx <= (MASKING_ORDER - 1); _mask_idx++) {
    xr[2][_mask_idx] = _shadow_x217_[_mask_idx];
  }

}

void AddConstant__V64 (/*inputs*/ DATATYPE state__[5][MASKING_ORDER],DATATYPE c__[MASKING_ORDER], /*outputs*/ DATATYPE stateR__[5][MASKING_ORDER]) {

  // Variables declaration
  DATATYPE _tmp1_;

  // Instructions (body)
  for (int _mask_idx = 0; _mask_idx <= (MASKING_ORDER - 1); _mask_idx++) {
    _tmp1_ = XOR(state__[2][_mask_idx],c__[_mask_idx]);
    stateR__[0][_mask_idx] = state__[0][_mask_idx];
    stateR__[1][_mask_idx] = state__[1][_mask_idx];
    stateR__[2][_mask_idx] = _tmp1_;
    stateR__[3][_mask_idx] = state__[3][_mask_idx];
    stateR__[4][_mask_idx] = state__[4][_mask_idx];
  }

}

void LinearLayer__V64 (/*inputs*/ DATATYPE state__[5][MASKING_ORDER], /*outputs*/ DATATYPE stateR__[5][MASKING_ORDER]) {

  // Variables declaration
  DATATYPE _tmp10_;
  DATATYPE _tmp11_;
  DATATYPE _tmp12_;
  DATATYPE _tmp13_;
  DATATYPE _tmp14_;
  DATATYPE _tmp15_;
  DATATYPE _tmp16_;
  DATATYPE _tmp2_;
  DATATYPE _tmp3_;
  DATATYPE _tmp4_;
  DATATYPE _tmp5_;
  DATATYPE _tmp6_;
  DATATYPE _tmp7_;
  DATATYPE _tmp8_;
  DATATYPE _tmp9_;

  // Instructions (body)
  for (int _mask_idx = 0; _mask_idx <= (MASKING_ORDER - 1); _mask_idx++) {
    _tmp2_ = R_ROTATE(state__[0][_mask_idx],19,64);
    _tmp3_ = XOR(state__[0][_mask_idx],_tmp2_);
    _tmp4_ = R_ROTATE(state__[0][_mask_idx],28,64);
    stateR__[0][_mask_idx] = XOR(_tmp3_,_tmp4_);
    _tmp5_ = R_ROTATE(state__[1][_mask_idx],61,64);
    _tmp6_ = XOR(state__[1][_mask_idx],_tmp5_);
    _tmp7_ = R_ROTATE(state__[1][_mask_idx],39,64);
    stateR__[1][_mask_idx] = XOR(_tmp6_,_tmp7_);
    _tmp8_ = R_ROTATE(state__[2][_mask_idx],1,64);
    _tmp9_ = XOR(state__[2][_mask_idx],_tmp8_);
    _tmp10_ = R_ROTATE(state__[2][_mask_idx],6,64);
    stateR__[2][_mask_idx] = XOR(_tmp9_,_tmp10_);
    _tmp11_ = R_ROTATE(state__[3][_mask_idx],10,64);
    _tmp12_ = XOR(state__[3][_mask_idx],_tmp11_);
    _tmp13_ = R_ROTATE(state__[3][_mask_idx],17,64);
    stateR__[3][_mask_idx] = XOR(_tmp12_,_tmp13_);
    _tmp14_ = R_ROTATE(state__[4][_mask_idx],7,64);
    _tmp15_ = XOR(state__[4][_mask_idx],_tmp14_);
    _tmp16_ = R_ROTATE(state__[4][_mask_idx],41,64);
    stateR__[4][_mask_idx] = XOR(_tmp15_,_tmp16_);
  }

}

/* main function */
void ascon12__ (/*inputs*/ DATATYPE input__[5][MASKING_ORDER], /*outputs*/ DATATYPE output__[5][MASKING_ORDER]) {

  // Variables declaration
  DATATYPE _tmp29_[5][MASKING_ORDER];
  DATATYPE _tmp30_[5][MASKING_ORDER];
  DATATYPE consts__[12][MASKING_ORDER];
  DATATYPE state__[5][MASKING_ORDER];

  // Instructions (body)
  consts__[0][0] = LIFT_64(240);
  for (int _mask_idx = 1; _mask_idx <= (MASKING_ORDER - 1); _mask_idx++) {
    consts__[0][_mask_idx] = LIFT_64(0);
    consts__[1][_mask_idx] = LIFT_64(0);
    consts__[2][_mask_idx] = LIFT_64(0);
    consts__[3][_mask_idx] = LIFT_64(0);
    consts__[4][_mask_idx] = LIFT_64(0);
    consts__[5][_mask_idx] = LIFT_64(0);
    consts__[6][_mask_idx] = LIFT_64(0);
    consts__[7][_mask_idx] = LIFT_64(0);
    consts__[8][_mask_idx] = LIFT_64(0);
    consts__[9][_mask_idx] = LIFT_64(0);
    consts__[10][_mask_idx] = LIFT_64(0);
    consts__[11][_mask_idx] = LIFT_64(0);
  }
  consts__[1][0] = LIFT_64(225);
  consts__[2][0] = LIFT_64(210);
  consts__[3][0] = LIFT_64(195);
  consts__[4][0] = LIFT_64(180);
  consts__[5][0] = LIFT_64(165);
  consts__[6][0] = LIFT_64(150);
  consts__[7][0] = LIFT_64(135);
  consts__[8][0] = LIFT_64(120);
  consts__[9][0] = LIFT_64(105);
  consts__[10][0] = LIFT_64(90);
  consts__[11][0] = LIFT_64(75);
  for (int _mask_idx = 0; _mask_idx <= (MASKING_ORDER - 1); _mask_idx++) {
    state__[0][_mask_idx] = input__[0][_mask_idx];
    state__[1][_mask_idx] = input__[1][_mask_idx];
    state__[2][_mask_idx] = input__[2][_mask_idx];
    state__[3][_mask_idx] = input__[3][_mask_idx];
    state__[4][_mask_idx] = input__[4][_mask_idx];
  }
  for (int i__ = 0; i__ <= 11; i__++) {
    AddConstant__V64(state__,consts__[i__],_tmp29_);
    Sbox__V64(_tmp29_,_tmp30_);
    LinearLayer__V64(_tmp30_,state__);
  }
  for (int _mask_idx = 0; _mask_idx <= (MASKING_ORDER - 1); _mask_idx++) {
    output__[0][_mask_idx] = state__[0][_mask_idx];
    output__[1][_mask_idx] = state__[1][_mask_idx];
    output__[2][_mask_idx] = state__[2][_mask_idx];
    output__[3][_mask_idx] = state__[3][_mask_idx];
    output__[4][_mask_idx] = state__[4][_mask_idx];
  }

}

/* Additional functions */
uint32_t bench_speed() {
  /* inputs */
  DATATYPE input__[5][MASKING_ORDER] = { 0 };
  /* outputs */
  DATATYPE output__[5][MASKING_ORDER] = { 0 };
  /* fun call */
  ascon12__(input__,output__);

  /* Returning the number of encrypted bytes */
  return 40;
}

/* **************************************************************** */
/*                            Usuba source                          */
/*                                                                  */
/*

 table Sbox(x :  v5 :: base)
  returns y :  v5 :: base
{
  4, 11, 31, 20, 26, 21, 9, 2, 27, 5, 8, 18, 29, 3, 6, 28, 30, 19, 7, 14, 0, 13, 17, 24, 16, 12, 1, 25, 22, 10, 15, 23
}


 node AddConstant(state :  u64x5 :: base,c :  u64 :: base)
  returns stateR :  u64x5 :: base
vars

let
  (stateR) = (state[0,1],(state[2] ^ c),state[3,4])
tel

 node LinearLayer(state :  u64x5 :: base)
  returns stateR :  u64x5 :: base
vars

let
  (stateR[0]) = ((state[0] ^ (state[0] >>> 19)) ^ (state[0] >>> 28));
  (stateR[1]) = ((state[1] ^ (state[1] >>> 61)) ^ (state[1] >>> 39));
  (stateR[2]) = ((state[2] ^ (state[2] >>> 1)) ^ (state[2] >>> 6));
  (stateR[3]) = ((state[3] ^ (state[3] >>> 10)) ^ (state[3] >>> 17));
  (stateR[4]) = ((state[4] ^ (state[4] >>> 7)) ^ (state[4] >>> 41))
tel

 node ascon12(input :  u64x5 :: base)
  returns output :  u64x5 :: base
vars
  consts :  u64[12] :: base,
  state :  u64x5[13] :: base
let
  (consts) = (240,225,210,195,180,165,150,135,120,105,90,75);
  (state[0]) = input;
  forall i in [0,11] {
    (state[(i + 1)]) = LinearLayer(Sbox(AddConstant(state[i],consts[i])))
  };
  (output) = state[12]
tel

*/
 